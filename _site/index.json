{
  "README.html": {
    "href": "README.html",
    "title": "BepInEx Universal Utilities | BepInEx Universal Utilities",
    "summary": "BepInEx Universal Utilities Universal Utilities for modding Unity games with BepInEx. Features Input framework for mapping actions to Unity keycodes, including modifiers Simple Json configuration system for when BepInEx configs aren't powerful enough Dependencies BepInEx NewtonsoftJson Netstandard 2.x (Target framework) (InputTrigger uses the HashCode utility for generating it's hashcode, to support other frameworks, clone this repository and generate the hashcode another way) Installation End Users Download the latest version from the Releases page. Unzip and copy the BepInExUniUtils.dll file into the BepInEx/plugins folder. Developers Currently there is no Nuget package for this, just reference the assembly directly in your IDE of choice. Input Framework The Input Framework is pretty straight forward. An InputTrigger is mapped to a list of AbstractActions that are all executed sequentially when the input is detected. Inputs can trigger once or repeatedly. The InputTrigger is a struct containing a main KeyCode that is used to detect the input, and an optional modifier KeyCode that must be held down to trigger it. Input Mappings Inputs are mapped to actions in the Input.json config file. This file is saved directly along other BepInEx configs. A default file will be generated if it doesn't exist, but here is an example: { \"InputActions\": [ { \"InputTrigger\": { \"Modifier\": \"None\", \"Key\": \"F9\" }, \"Actions\": [ \"DummyAction\" ] } ], \"RepeatingInputActions\": [ { \"InputTrigger\": { \"Modifier\": \"RightShift\", \"Key\": \"F10\" }, \"Actions\": [ \"DummyAction\", \"DummyAction\" ] } ] } Creating Actions Creating new actions is as simple as extending AbstractAction and implementing the Execute method. The execute method has no arguments and the ID of the action is handled automatically. /// <summary> /// A dummy action that does nothing. /// </summary> /// <param name=\"id\">The ID of the action.</param> public class DummyAction(string id) :AbstractAction(id) { public override void Execute() { UniUtilsPlugin.Logger.LogDebug(\"This does nothing\"); } } Registering Custom Actions Actions can be manually registered by passing each Type that extends AbstractActions to the method UniUtilsPlugin.RegisterAction(Type) However there is a much simpler method that uses reflection to automatically register all actions. Simply implement this method in your plugin and call it in Awake(). /// <summary> /// Automatically registers all actions in this assembly. /// </summary> private static void RegisterInternalActions() { foreach (Type type in Assembly.GetExecutingAssembly().GetTypes()) { if(type.IsSubclassOf(typeof(AbstractAction))) UniUtilsPlugin.RegisterAction(type); } } Json Configs Json can be a powerful tool for serializing data and allows for much more complex functionality over TOML. It does have a few drawbacks though, the inability to add comments and readability are the biggest when using it for configs. My recommendation would be to use the standard BepInEx config unless you need to serialize collections or types not supported by the standard BepInEx config. That being said, you can simply extend JsonConfigBase and implement GenerateDefaultConfig(), LoadConfig(), and SaveConfig() if you want to create a Json config. There is also an EventHandler ConfigLoaded in the event you need to trigger code upon loading the config. You should make sure to call OnConfigLoaded() at the end of your LoadConfig() method to trigger the ConfigLoaded event. See InputConfig for an example implementation."
  },
  "api/BepInExUniUtils.Actions.DummyAction.html": {
    "href": "api/BepInExUniUtils.Actions.DummyAction.html",
    "title": "Class DummyAction | BepInEx Universal Utilities",
    "summary": "Class DummyAction Namespace BepInExUniUtils.Actions Assembly BepInExUniUtils.dll A dummy action that does nothing. public class DummyAction : AbstractAction Inheritance object AbstractAction DummyAction Inherited Members AbstractAction.Id object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors DummyAction(string) A dummy action that does nothing. public DummyAction(string id) Parameters id string The ID of the action. Methods Execute() Does nothing. public override void Execute()"
  },
  "api/BepInExUniUtils.Actions.html": {
    "href": "api/BepInExUniUtils.Actions.html",
    "title": "Namespace BepInExUniUtils.Actions | BepInEx Universal Utilities",
    "summary": "Namespace BepInExUniUtils.Actions Classes DummyAction A dummy action that does nothing."
  },
  "api/BepInExUniUtils.Configuration.InputConfig.html": {
    "href": "api/BepInExUniUtils.Configuration.InputConfig.html",
    "title": "Class InputConfig | BepInEx Universal Utilities",
    "summary": "Class InputConfig Namespace BepInExUniUtils.Configuration Assembly BepInExUniUtils.dll Config for mapping inputs to custom actions. [JsonObject(MemberSerialization.OptIn)] public class InputConfig : JsonConfigBase Inheritance object JsonConfigBase InputConfig Inherited Members JsonConfigBase.ConfigName JsonConfigBase.DirPath JsonConfigBase.ConfigLoaded JsonConfigBase.FilePath JsonConfigBase.DoesConfigExist() JsonConfigBase.LoadOrCreateConfig() JsonConfigBase.GetSerializerSettings() JsonConfigBase.OnConfigLoaded() object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors InputConfig(string, string) Config for mapping inputs to custom actions. public InputConfig(string configName, string dirPath) Parameters configName string Name of the config file. dirPath string Directory path for the config file. Fields InputActions Input mappings for non-repeating actions. [JsonProperty] public readonly List<InputMapping> InputActions Field Value List<InputMapping> RepeatingInputActions Input mappings for repeating actions. [JsonProperty] public readonly List<InputMapping> RepeatingInputActions Field Value List<InputMapping> Methods GenerateDefaultConfig() Generates the default config. protected override void GenerateDefaultConfig() LoadConfig() Loads this config from the file system. public override void LoadConfig() SaveConfig() Saves the current config to the file system. public override void SaveConfig()"
  },
  "api/BepInExUniUtils.Configuration.JsonConfigBase.html": {
    "href": "api/BepInExUniUtils.Configuration.JsonConfigBase.html",
    "title": "Class JsonConfigBase | BepInEx Universal Utilities",
    "summary": "Class JsonConfigBase Namespace BepInExUniUtils.Configuration Assembly BepInExUniUtils.dll Base class for JSON configurations. [JsonObject(MemberSerialization.OptIn)] public abstract class JsonConfigBase Inheritance object JsonConfigBase Derived InputConfig Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors JsonConfigBase(string, string) Base class for JSON configurations. protected JsonConfigBase(string configName, string dirPath) Parameters configName string Name of the config file. dirPath string Directory path for the config file. Fields ConfigName The name of the config file. public readonly string ConfigName Field Value string DirPath The directory path for the config file. public readonly string DirPath Field Value string Properties FilePath Filepath of the config file. public string FilePath { get; } Property Value string String with the filepath for this config. Methods DoesConfigExist() Checks if this config exists on the file system. public bool DoesConfigExist() Returns bool True if the file is found. GenerateDefaultConfig() Abstract method to generates the default config. Must be overridden by the derived class. protected abstract void GenerateDefaultConfig() GetSerializerSettings() Gets the serializer settings for the config. The default settings are indented formatting. public virtual JsonSerializerSettings GetSerializerSettings() Returns JsonSerializerSettings The serializer settings for the config. LoadConfig() Abstract method to load the config. Must be overridden by the derived class. public abstract void LoadConfig() LoadOrCreateConfig() Loads or creates the config. public virtual JsonConfigBase LoadOrCreateConfig() Returns JsonConfigBase This config after being loaded or created. OnConfigLoaded() Event invocation for when the config is loaded. protected virtual void OnConfigLoaded() SaveConfig() Abstract method to save the config. Must be overridden by the derived class. public abstract void SaveConfig() Events ConfigLoaded An event that should be invoked when the config is loaded. public event EventHandler ConfigLoaded Event Type EventHandler"
  },
  "api/BepInExUniUtils.Configuration.html": {
    "href": "api/BepInExUniUtils.Configuration.html",
    "title": "Namespace BepInExUniUtils.Configuration | BepInEx Universal Utilities",
    "summary": "Namespace BepInExUniUtils.Configuration Classes InputConfig Config for mapping inputs to custom actions. JsonConfigBase Base class for JSON configurations."
  },
  "api/BepInExUniUtils.InputFramework.AbstractAction.html": {
    "href": "api/BepInExUniUtils.InputFramework.AbstractAction.html",
    "title": "Class AbstractAction | BepInEx Universal Utilities",
    "summary": "Class AbstractAction Namespace BepInExUniUtils.InputFramework Assembly BepInExUniUtils.dll An abstract class representing an action. public abstract class AbstractAction Inheritance object AbstractAction Derived DummyAction Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Constructors AbstractAction(string) An abstract class representing an action. protected AbstractAction(string id) Parameters id string The ID of the action. Fields Id The ID of the action. Automatically set when the action is created. public readonly string Id Field Value string Methods Execute() This function is called when the action is executed. This must be overwritten by the derived class. public abstract void Execute()"
  },
  "api/BepInExUniUtils.InputFramework.InputMapping.html": {
    "href": "api/BepInExUniUtils.InputFramework.InputMapping.html",
    "title": "Struct InputMapping | BepInEx Universal Utilities",
    "summary": "Struct InputMapping Namespace BepInExUniUtils.InputFramework Assembly BepInExUniUtils.dll A class used for serializing input mappings. public struct InputMapping Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors InputMapping(InputTrigger, List<string>) A class used for serializing input mappings. public InputMapping(InputTrigger inputTrigger, List<string> actions) Parameters inputTrigger InputTrigger actions List<string> Fields Actions The names of the actions to trigger when the input is pressed. public List<string> Actions Field Value List<string> InputTrigger The input trigger to listen for. public InputTrigger InputTrigger Field Value InputTrigger Methods ToKeyValuePair() Converts the input action to a key value pair. public KeyValuePair<InputTrigger, List<string>> ToKeyValuePair() Returns KeyValuePair<InputTrigger, List<string>> The key value pair representing this input action."
  },
  "api/BepInExUniUtils.InputFramework.InputTrigger.html": {
    "href": "api/BepInExUniUtils.InputFramework.InputTrigger.html",
    "title": "Struct InputTrigger | BepInEx Universal Utilities",
    "summary": "Struct InputTrigger Namespace BepInExUniUtils.InputFramework Assembly BepInExUniUtils.dll A struct representing an input. [JsonObject(MemberSerialization.OptIn)] public struct InputTrigger : IEquatable<InputTrigger> Implements IEquatable<InputTrigger> Inherited Members object.Equals(object, object) object.GetType() object.ReferenceEquals(object, object) Constructors InputTrigger(KeyCode, KeyCode) A struct representing an input. public InputTrigger(KeyCode key, KeyCode modifier = KeyCode.None) Parameters key KeyCode The main key to listen for. modifier KeyCode A modifier key that must be held when pressing the main key for the input to fire. Can be ommited. Fields Key Main key to listen for. [JsonProperty] [JsonConverter(typeof(StringEnumConverter))] public readonly KeyCode Key Field Value KeyCode Modifier Modifier that must be held when pressing the main key for the input to fire. [JsonProperty] [JsonConverter(typeof(StringEnumConverter))] public readonly KeyCode Modifier Field Value KeyCode Methods Equals(InputTrigger) Checks if this InputTrigger is equal to another InputTrigger. public bool Equals(InputTrigger other) Parameters other InputTrigger The other InputTrigger to compare to. Returns bool True if the two inputs are equal. Equals(object) Checks if this InputTrigger is equal to another object. public override bool Equals(object obj) Parameters obj object The object to compare to. Returns bool True if the object is a InputTrigger and is equal to this one. GetHashCode() Gets the hash code for this InputTrigger. public override int GetHashCode() Returns int The hash code for this InputTrigger. IsDown() Checks if the input is currently down. Only triggers once until the main key is released. public bool IsDown() Returns bool True if the input is currently down. IsPressed() Checks if the input is currently pressed. Will return true every tick while the key is held down. public bool IsPressed() Returns bool True if the input is currently pressed. ToString() Converts the input to a string. public override string ToString() Returns string The string representation of the input. TryParse(string, out bool) Attempts to convert a string to a InputTrigger. public static InputTrigger TryParse(string input, out bool success) Parameters input string The string to convert. success bool True if the value was successfully parsed. Returns InputTrigger The parsed InputTrigger, or a default value if parsing failed."
  },
  "api/BepInExUniUtils.InputFramework.html": {
    "href": "api/BepInExUniUtils.InputFramework.html",
    "title": "Namespace BepInExUniUtils.InputFramework | BepInEx Universal Utilities",
    "summary": "Namespace BepInExUniUtils.InputFramework Classes AbstractAction An abstract class representing an action. Structs InputMapping A class used for serializing input mappings. InputTrigger A struct representing an input."
  },
  "api/BepInExUniUtils.MyPluginInfo.html": {
    "href": "api/BepInExUniUtils.MyPluginInfo.html",
    "title": "Class MyPluginInfo | BepInEx Universal Utilities",
    "summary": "Class MyPluginInfo Namespace BepInExUniUtils Assembly BepInExUniUtils.dll public static class MyPluginInfo Inheritance object MyPluginInfo Inherited Members object.Equals(object) object.Equals(object, object) object.GetHashCode() object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) object.ToString() Fields PLUGIN_GUID public const string PLUGIN_GUID = \"BepInExUniUtils\" Field Value string PLUGIN_NAME public const string PLUGIN_NAME = \"BepInEx Universal Utils\" Field Value string PLUGIN_VERSION public const string PLUGIN_VERSION = \"0.1.0\" Field Value string"
  },
  "api/BepInExUniUtils.UniUtilsPlugin.html": {
    "href": "api/BepInExUniUtils.UniUtilsPlugin.html",
    "title": "Class UniUtilsPlugin | BepInEx Universal Utilities",
    "summary": "Class UniUtilsPlugin Namespace BepInExUniUtils Assembly BepInExUniUtils.dll Main class for the plugin. [BepInPlugin(\"BepInExUniUtils\", \"BepInEx Universal Utils\", \"0.1.0\")] public class UniUtilsPlugin : BaseUnityPlugin Inheritance object Object Component Behaviour MonoBehaviour BaseUnityPlugin UniUtilsPlugin Inherited Members BaseUnityPlugin.Info BaseUnityPlugin.Logger BaseUnityPlugin.Config MonoBehaviour.Internal_CancelInvokeAll() MonoBehaviour.Internal_IsInvokingAll() MonoBehaviour.Invoke(string, float) MonoBehaviour.InvokeRepeating(string, float, float) MonoBehaviour.CancelInvoke() MonoBehaviour.CancelInvoke(string) MonoBehaviour.IsInvoking(string) MonoBehaviour.IsInvoking() MonoBehaviour.StartCoroutine(IEnumerator) MonoBehaviour.StartCoroutine_Auto(IEnumerator) MonoBehaviour.StartCoroutine_Auto_Internal(IEnumerator) MonoBehaviour.StartCoroutine(string, object) MonoBehaviour.StartCoroutine(string) MonoBehaviour.StopCoroutine(string) MonoBehaviour.StopCoroutine(IEnumerator) MonoBehaviour.StopCoroutine(Coroutine) MonoBehaviour.StopCoroutineViaEnumerator_Auto(IEnumerator) MonoBehaviour.StopCoroutine_Auto(Coroutine) MonoBehaviour.StopAllCoroutines() MonoBehaviour.print(object) MonoBehaviour.useGUILayout Behaviour.enabled Behaviour.isActiveAndEnabled Component.GetComponent(Type) Component.GetComponentFastPath(Type, IntPtr) Component.GetComponent<T>() Component.GetComponent(string) Component.GetComponentInChildren(Type, bool) Component.GetComponentInChildren(Type) Component.GetComponentInChildren<T>() Component.GetComponentInChildren<T>(bool) Component.GetComponentsInChildren(Type) Component.GetComponentsInChildren(Type, bool) Component.GetComponentsInChildren<T>(bool) Component.GetComponentsInChildren<T>(bool, List<T>) Component.GetComponentsInChildren<T>() Component.GetComponentsInChildren<T>(List<T>) Component.GetComponentInParent(Type) Component.GetComponentInParent<T>() Component.GetComponentsInParent(Type) Component.GetComponentsInParent(Type, bool) Component.GetComponentsInParent<T>(bool) Component.GetComponentsInParent<T>(bool, List<T>) Component.GetComponentsInParent<T>() Component.GetComponents(Type) Component.GetComponentsForListInternal(Type, object) Component.GetComponents(Type, List<Component>) Component.GetComponents<T>(List<T>) Component.GetComponents<T>() Component.CompareTag(string) Component.SendMessageUpwards(string, object, SendMessageOptions) Component.SendMessageUpwards(string, object) Component.SendMessageUpwards(string) Component.SendMessageUpwards(string, SendMessageOptions) Component.SendMessage(string, object, SendMessageOptions) Component.SendMessage(string, object) Component.SendMessage(string) Component.SendMessage(string, SendMessageOptions) Component.BroadcastMessage(string, object, SendMessageOptions) Component.BroadcastMessage(string, object) Component.BroadcastMessage(string) Component.BroadcastMessage(string, SendMessageOptions) Component.transform Component.gameObject Component.tag Object.m_CachedPtr Object.OffsetOfInstanceIDInCPlusPlusObject Object.Internal_CloneSingle(Object) Object.Internal_CloneSingleWithParent(Object, Transform, bool) Object.Internal_InstantiateSingle(Object, Vector3, Quaternion) Object.INTERNAL_CALL_Internal_InstantiateSingle(Object, ref Vector3, ref Quaternion) Object.Internal_InstantiateSingleWithParent(Object, Transform, Vector3, Quaternion) Object.INTERNAL_CALL_Internal_InstantiateSingleWithParent(Object, Transform, ref Vector3, ref Quaternion) Object.GetOffsetOfInstanceIDInCPlusPlusObject() Object.EnsureRunningOnMainThread() Object.Destroy(Object, float) Object.Destroy(Object) Object.DestroyImmediate(Object, bool) Object.DestroyImmediate(Object) Object.FindObjectsOfType(Type) Object.DontDestroyOnLoad(Object) Object.DestroyObject(Object, float) Object.DestroyObject(Object) Object.FindSceneObjectsOfType(Type) Object.FindObjectsOfTypeIncludingAssets(Type) Object.FindObjectsOfTypeAll(Type) Object.ToString() Object.DoesObjectWithInstanceIDExist(int) Object.GetInstanceID() Object.GetHashCode() Object.Equals(object) Object.CompareBaseObjects(Object, Object) Object.IsNativeObjectAlive(Object) Object.GetCachedPtr() Object.Instantiate(Object, Vector3, Quaternion) Object.Instantiate(Object, Vector3, Quaternion, Transform) Object.Instantiate(Object) Object.Instantiate(Object, Transform) Object.Instantiate(Object, Transform, bool) Object.Instantiate<T>(T) Object.Instantiate<T>(T, Vector3, Quaternion) Object.Instantiate<T>(T, Vector3, Quaternion, Transform) Object.Instantiate<T>(T, Transform) Object.Instantiate<T>(T, Transform, bool) Object.FindObjectsOfType<T>() Object.FindObjectOfType<T>() Object.CheckNullArgument(object, string) Object.FindObjectOfType(Type) Object.name Object.hideFlags object.Equals(object, object) object.GetType() object.MemberwiseClone() object.ReferenceEquals(object, object) Fields InputFileName Name of the input config file. public const string InputFileName = \"Input\" Field Value string Inputs Input config object that handles loading and saving the input config file. public static readonly InputConfig Inputs Field Value InputConfig ReloadInputsKey Key to reload the input config file. public static ConfigEntry<KeyCode> ReloadInputsKey Field Value ConfigEntry<KeyCode> Methods ClearInputActions() Clears the input actions. public static void ClearInputActions() CreateAction(string) Attempts to create an action from the registry. If the action is not found in the registry, it will try to create it from the assembly qualified name. public static AbstractAction CreateAction(string name) Parameters name string The ID of the action to create. Returns AbstractAction The created action, or null if the action could not be created. RegisterAction(Type) Adds an action to the registry. public static bool RegisterAction(Type abstractActionType) Parameters abstractActionType Type The type of action to register. Should be a subclass of AbstractAction. Returns bool Whether the action was registered successfully. RegisterInputActions(List<InputMapping>, ref Dictionary<InputTrigger, List<AbstractAction>>) A system for converting serialized input mappings to input triggers and abstract actions. public static void RegisterInputActions(List<InputMapping> inputMappings, ref Dictionary<InputTrigger, List<AbstractAction>> mappingsDict) Parameters inputMappings List<InputMapping> The list of input actions to read from. mappingsDict Dictionary<InputTrigger, List<AbstractAction>> The dictionary of actions to write the actions to. ResetInputMappings(object, EventArgs) Clears the input actions and registers them again from the default sections in the config. protected static void ResetInputMappings(object sender, EventArgs eventArgs) Parameters sender object eventArgs EventArgs"
  },
  "api/BepInExUniUtils.html": {
    "href": "api/BepInExUniUtils.html",
    "title": "Namespace BepInExUniUtils | BepInEx Universal Utilities",
    "summary": "Namespace BepInExUniUtils Classes MyPluginInfo UniUtilsPlugin Main class for the plugin."
  },
  "docs/README.html": {
    "href": "docs/README.html",
    "title": "BepInEx Universal Utilities | BepInEx Universal Utilities",
    "summary": "BepInEx Universal Utilities Universal Utilities for modding Unity games with BepInEx. Features Input framework for mapping actions to Unity keycodes, including modifiers Simple Json configuration system for when BepInEx configs aren't powerful enough Dependencies BepInEx NewtonsoftJson Netstandard 2.x (Target framework) (InputTrigger uses the HashCode utility for generating it's hashcode, to support other frameworks, clone this repository and generate the hashcode another way) Installation End Users Download the latest version from the Releases page. Unzip and copy the BepInExUniUtils.dll file into the BepInEx/plugins folder. Developers Currently there is no Nuget package for this, just reference the assembly directly in your IDE of choice. Input Framework The Input Framework is pretty straight forward. An InputTrigger is mapped to a list of AbstractActions that are all executed sequentially when the input is detected. Inputs can trigger once or repeatedly. The InputTrigger is a struct containing a main KeyCode that is used to detect the input, and an optional modifier KeyCode that must be held down to trigger it. Input Mappings Inputs are mapped to actions in the Input.json config file. This file is saved directly along other BepInEx configs. A default file will be generated if it doesn't exist, but here is an example: { \"InputActions\": [ { \"InputTrigger\": { \"Modifier\": \"None\", \"Key\": \"F9\" }, \"Actions\": [ \"DummyAction\" ] } ], \"RepeatingInputActions\": [ { \"InputTrigger\": { \"Modifier\": \"RightShift\", \"Key\": \"F10\" }, \"Actions\": [ \"DummyAction\", \"DummyAction\" ] } ] } Creating Actions Creating new actions is as simple as extending AbstractAction and implementing the Execute method. The execute method has no arguments and the ID of the action is handled automatically. /// <summary> /// A dummy action that does nothing. /// </summary> /// <param name=\"id\">The ID of the action.</param> public class DummyAction(string id) :AbstractAction(id) { public override void Execute() { UniUtilsPlugin.Logger.LogDebug(\"This does nothing\"); } } Registering Custom Actions Actions can be manually registered by passing each Type that extends AbstractActions to the method UniUtilsPlugin.RegisterAction(Type) However there is a much simpler method that uses reflection to automatically register all actions. Simply implement this method in your plugin and call it in Awake(). /// <summary> /// Automatically registers all actions in this assembly. /// </summary> private static void RegisterInternalActions() { foreach (Type type in Assembly.GetExecutingAssembly().GetTypes()) { if(type.IsSubclassOf(typeof(AbstractAction))) UniUtilsPlugin.RegisterAction(type); } } Json Configs Json can be a powerful tool for serializing data and allows for much more complex functionality over TOML. It does have a few drawbacks though, the inability to add comments and readability are the biggest when using it for configs. My recommendation would be to use the standard BepInEx config unless you need to serialize collections or types not supported by the standard BepInEx config. That being said, you can simply extend JsonConfigBase and implement GenerateDefaultConfig(), LoadConfig(), and SaveConfig() if you want to create a Json config. There is also an EventHandler ConfigLoaded in the event you need to trigger code upon loading the config. You should make sure to call OnConfigLoaded() at the end of your LoadConfig() method to trigger the ConfigLoaded event. See InputConfig for an example implementation."
  },
  "index.html": {
    "href": "index.html",
    "title": "BepInEx Universal Utilities | BepInEx Universal Utilities",
    "summary": "BepInEx Universal Utilities Universal Utilities for modding Unity games with BepInEx. Features Input framework for mapping actions to Unity keycodes, including modifiers Simple Json configuration system for when BepInEx configs aren't powerful enough Dependencies BepInEx NewtonsoftJson Netstandard 2.x (Target framework) (InputTrigger uses the HashCode utility for generating it's hashcode, to support other frameworks, clone this repository and generate the hashcode another way) Installation End Users Download the latest version from the Releases page. Unzip and copy the BepInExUniUtils.dll file into the BepInEx/plugins folder. Developers Currently there is no Nuget package for this, just reference the assembly directly in your IDE of choice. Input Framework The Input Framework is pretty straight forward. An InputTrigger is mapped to a list of AbstractActions that are all executed sequentially when the input is detected. Inputs can trigger once or repeatedly. The InputTrigger is a struct containing a main KeyCode that is used to detect the input, and an optional modifier KeyCode that must be held down to trigger it. Input Mappings Inputs are mapped to actions in the Input.json config file. This file is saved directly along other BepInEx configs. A default file will be generated if it doesn't exist, but here is an example: { \"InputActions\": [ { \"InputTrigger\": { \"Modifier\": \"None\", \"Key\": \"F9\" }, \"Actions\": [ \"DummyAction\" ] } ], \"RepeatingInputActions\": [ { \"InputTrigger\": { \"Modifier\": \"RightShift\", \"Key\": \"F10\" }, \"Actions\": [ \"DummyAction\", \"DummyAction\" ] } ] } Creating Actions Creating new actions is as simple as extending AbstractAction and implementing the Execute method. The execute method has no arguments and the ID of the action is handled automatically. /// <summary> /// A dummy action that does nothing. /// </summary> /// <param name=\"id\">The ID of the action.</param> public class DummyAction(string id) :AbstractAction(id) { public override void Execute() { UniUtilsPlugin.Logger.LogDebug(\"This does nothing\"); } } Registering Custom Actions Actions can be manually registered by passing each Type that extends AbstractActions to the method UniUtilsPlugin.RegisterAction(Type) However there is a much simpler method that uses reflection to automatically register all actions. Simply implement this method in your plugin and call it in Awake(). /// <summary> /// Automatically registers all actions in this assembly. /// </summary> private static void RegisterInternalActions() { foreach (Type type in Assembly.GetExecutingAssembly().GetTypes()) { if(type.IsSubclassOf(typeof(AbstractAction))) UniUtilsPlugin.RegisterAction(type); } } Json Configs Json can be a powerful tool for serializing data and allows for much more complex functionality over TOML. It does have a few drawbacks though, the inability to add comments and readability are the biggest when using it for configs. My recommendation would be to use the standard BepInEx config unless you need to serialize collections or types not supported by the standard BepInEx config. That being said, you can simply extend JsonConfigBase and implement GenerateDefaultConfig(), LoadConfig(), and SaveConfig() if you want to create a Json config. There is also an EventHandler ConfigLoaded in the event you need to trigger code upon loading the config. You should make sure to call OnConfigLoaded() at the end of your LoadConfig() method to trigger the ConfigLoaded event. See InputConfig for an example implementation."
  }
}